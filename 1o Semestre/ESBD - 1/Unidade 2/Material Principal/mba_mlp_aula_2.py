# -*- coding: utf-8 -*-
"""MBA - MLP - Aula 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HiUvqln49QWKQBgndx-ciyN5qTYT9ac4

# **Árvores**

O uso de árvores em computação pode ser muito apropriado quando precisa-se manter constantes baixas para operações de inserção, busca, entre outras.

**Importante:** para as constantes permanecerem baixas as arvores devem estar balanceadas.

Para a manipulação de árvores será utilizada a biblioteca bintrees. O comando abaixo é responsável pela instalação desta biblioteca.
"""

!pip install bintrees

"""## **Operações Básicas**

chave, conteúdo 
"""

from bintrees import AVLTree


# declarando Árvore Binária Balanceada
tree = AVLTree()

# inserindo dados na árvore
tree.insert(0, 50)
tree.insert(1, 55)
tree.insert(2, 60)
tree.insert(3, 65)
tree.insert(4, 70)

# removendo dados da árvores
tree.remove(3)
tree.remove(4)

# retornando valores na árvore
value = tree.get(2)
print("valor do elemento com chave 2 =", value)

# valor mínimo na árvore
min_item = tree.min_item()
print("menor elemento =", min_item)

# valor máximo na árvore
max_item = tree.max_item()
print("maior elemento =", max_item)

# sucessor na árvore
succ_item = tree.succ_item(1)
print("sucessor do elemento 1 =", succ_item)

# antecessor na árvore
prev_item = tree.prev_item(1)
print("predecessor do elemento 1 =", prev_item)

"""# **Dicionários**

Em Python, a utilização de dicionários para indexação de dados é muito comum. Com ela é possível aumentar a performance de algumas tarefas como buscas e inserções (no melhor caso, O(1)), além de manter dados relacionados melhor organizados dentro da aplicação.

**Importante**: dicionários em Python são estruturas não ordenadas.

Abaixo encontram-se alguns exemplos de uso dessa estrutura.

## **Operações Básicas**

### Declararando dicionários

chave : conteúdo
"""

# declarando dict vazio
empty_dict = {}
other_empty_dict = dict()

print("empty_dict =", empty_dict)
print("other_empty_dict =", other_empty_dict)

# declarando dict de vogais em ordem alfabética
people = {
    'a': 1,
    'e': 2,
    'i': 3,
    'o': 4,
    'u': 5
}

print("people =", people)

# declarando dict com dados de filmes
movies = {
    '1234': {'name': 'Filme 1', 'year': '2000'},
    '5678': {'name': 'Filme 2', 'year': '2002'}
}

print("movies =", movies)

"""### Inserindo dados em dicionários"""

# inserindo dados de filmes em dict
movies['9101'] = {'name': 'Filme 3', 'year': '2004'}

print("movies =", movies)

# também é possível inserir ou fazer merge de dados utilizando o método .update
movies.update({
    '1121': {'name': 'Filme 4', 'year': '2005'}
})

print("movies =", movies)

"""### Removendo dados em dicionários

"""

# removendo dados de filmes em dict através de chave
movies.pop('1121')

print("movies =", movies)

# removendo último dado inserido
movies.popitem()

print("movies =", movies)

# deletando chave através da keyword del
del movies['5678']

print("movies =", movies)

"""### Buscando dados em dicionários"""

# causa exceção se a chave não for encontrada
movie_info = movies['1234']

print("infomações do filme 1234 =", movie_info)

# retorna o segundo parametro se a chave não for encontrada
movie_info = movies.get('123', {})

print("infomações do filme 1234 =", movie_info)

"""### Dict Comprehension"""

# função auxiliar - retorna hexadecimal de cor a partir do nome
def get_color_hex(color_name):

    if color_name == 'red':
        return '#FF0000'
    elif color_name == 'green':
        return '#00FF00'
    elif color_name == 'blue':
        return '#0000FF'
    return 'color not found'


color_names = ['red', 'green', 'blue']


# declarando dicionários usando forma reduzida (dict comprehension)
color_info = {color_name: get_color_hex(color_name) for color_name in color_names}

print(color_info)

"""### Valores mínimos e máximos"""

# menor chave do dicionário
def dict_min_key(d):
    return min(d.keys())


# maior chave do dicionário
def dict_max_key(d):
    return max(d.keys())


# menor valor do dicionário
def dict_min_value(d):
    return min(d.values())


# maior valor do dicionário
def dict_max_value(d):
    return max(d.values())


# ordem de algumas letras do alfabeto
alphabet_order = {
    1: 'a',
    2: 'b',
    3: 'c',
    4: 'd',
    5: 'e',
    6: 'f',
    7: 'g'
}

min_key = dict_min_key(alphabet_order)
max_key = dict_max_key(alphabet_order)
min_value = dict_min_value(alphabet_order)
max_value = dict_max_value(alphabet_order)

print("min_key =", min_key, "; max_key =", max_key, "; min_value =", min_value, "; max_value =", max_value)

"""# **Benchmark**

Comparando desempenho de Árvores Balanceadas e Dicionários
"""

import time


tree = AVLTree()
d = {}


# inserções
start = time.time()
for i in range(200_000):
    tree.insert(i, i)
diff_time = time.time() - start

print(f'Tree Insertion: {diff_time}s')

start = time.time()
for i in range(200_000):
    d[i] = i
diff_time = time.time() - start

print(f'Dict Insertion: {diff_time}s')


# buscas
value = -1
key = 199_999
start = time.time()
for _ in range(10_000):
    value = tree.get(key)
diff_time = time.time() - start

print(f'Tree Lookup {diff_time}s')

value = -1
key = 199_999
start = time.time()
for _ in range(10_000):
    value = d.get(key)
diff_time = time.time() - start

print(f'Dict Lookup {diff_time}s')


# valor mínimo
start = time.time()
for _ in range(10_000):
    value = tree.min_item()
diff_time = time.time() - start

print(f'Tree Min Value {diff_time}s')

start = time.time()
for _ in range(10_000):
    value = dict_min_value(d)
diff_time = time.time() - start

print(f'Dict Min Value {diff_time}s')


# valor máximo
start = time.time()
for _ in range(10_000):
    value = tree.max_item()
diff_time = time.time() - start

print(f'Tree Max Value {diff_time}s')

start = time.time()
for _ in range(10_000):
    value = dict_max_value(d)
diff_time = time.time() - start

print(f'Dict Max Value {diff_time}s')