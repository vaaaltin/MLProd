# -*- coding: utf-8 -*-
"""MBA - MLP - Atividade 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IIQyIG6DchtF1Saqpnb6hQJ-R9iPYC9R

# **Atividade 2**

O código abaixo é responsável por gerar a rede de amigos descrita no enunciado da atividade 2. As únicas partes que devem ser alteradas neste código são: (i) a função `_search` e (ii) os parâmetros (números de vértices e arestas) da função que gera a rede. O entendimento do código é bem importante e pode facilitar na implementação.
"""

import random
import uuid


class Person(object):

    def __init__(self, uid, s_type):
        self._uid = uid
        self._s_type = s_type

    def get_uid(self):
        return self._uid
    
    def get_s_type(self):
        return self._s_type


class FriendNetwork(object):

    def __init__(self, people_num, connections_num):
        self._people_num = people_num
        self._connections_num = connections_num
        self._graph = self._generate_graph()

    def _generate_graph(self):

        peoples = []
        for people_index in range(self._people_num):
            uid = str(uuid.uuid4())
            s_type = 'female' if people_index < (self._people_num // 2)  else 'male'
            peoples.append(Person(uid, s_type))

        graph = {}
        while sum([*map(lambda values: len(values['friends']), graph.values())]) < self._connections_num:
            person, friend = random.sample(peoples, 2)
            person_uid = person.get_uid()
            friend_uid = friend.get_uid()

            if person_uid not in graph:
                graph[person_uid] = {
                    'this': person,
                    'friends': []
                }

            if friend_uid not in graph:
                graph[friend_uid] = {
                    'this': friend,
                    'friends': []
                }

            if person_uid == friend_uid or \
                friend_uid in graph[person_uid]['friends'] or \
                    person_uid in graph[friend_uid]['friends']:
                continue

            graph[person_uid]['friends'].append(friend)
            graph[friend_uid]['friends'].append(person)

        peoples_to_remove = []
        for person_uid in graph:
            friends_types = [*map(lambda p: p.get_s_type(), graph[person_uid]['friends'])]
            person_type = graph[person_uid]['this'].get_s_type()
            if ('male' not in friends_types or 'female' not in friends_types) and person_type in friends_types:
                peoples_to_remove.append({'person_uid': person_uid, 'remove_from': graph[person_uid]['friends']})

        for person_props in peoples_to_remove:
            for friend in person_props['remove_from']:
                person_index = [*map(lambda friend: friend.get_uid(),
                    graph[friend.get_uid()]['friends'])].index(person_props['person_uid'])
                del graph[friend.get_uid()]['friends'][person_index]
            del graph[person_props['person_uid']]

        return graph
    
    def get_person_by_uid(self, uid):
        return self._graph[uid]['this']

    def _search(self, person_uid, friend_uid):
        '''
        TODO
        
        Esta função DEVE retornar uma lista com o caminho (incluindo origem e destino)
        percorrido para encontrar o friend_uid partindo do person_uid
        '''

        path = []

        return path

    def get_separation_degree(self):
       
        total_paths_len = 0
        for _ in range(100):
            person_uid, friend_uid = random.sample([*self._graph.keys()], 2)
            path = self._search(person_uid, friend_uid)
            total_paths_len += len(path) - 1

        return total_paths_len / 100


if __name__ == '__main__':

    friend_network = FriendNetwork(100, 500)
    separation_degree = friend_network.get_separation_degree()
    print(separation_degree)